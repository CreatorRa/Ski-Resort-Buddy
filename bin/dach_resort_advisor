# ===============
# DACH Resort Advisor - Seasonal Insights (Julia)
# ===============
# One-file script that:
# 1) Loads `ski-regions-data.csv` and normalizes columns
# 2) Computes New Snow (Snow_New (cm))
# 3) Filters by date range or ski season
# 4) Runs QC checks and prints warnings
# 5) Prints key figures and tabular overviews directly in the terminal
# 6) Optional: grouped tables per Region/Country for every metric
#
# Install deps once:
#   import Pkg
#   Pkg.add(["CSV","DataFrames","Dates","Statistics","Printf","PrettyTables","Plots"])
#
# Run:
#   julia --project=. bin/dach_resort_advisor
#   # with explicit CSV path:
#   julia --project=. bin/dach_resort_advisor /path/to/ski-regions-data.csv
#
# Filters via CLI args or ENV:
#   --from YYYY-MM-DD  --to YYYY-MM-DD   (ENV: FROM_DATE / TO_DATE)
#   --season WINTER|SUMMER|ALL           (ENV: SEASON)
#   REGION=Tirol COUNTRY=AT julia --project=. bin/dach_resort_advisor
#
# Season definitions (by month):
#   WINTER = Nov–Apr (11,12,1,2,3,4) | SUMMER = May–Oct (5..10)

# Author, John , Shayan, Isaac, Carter

using CSV
using DataFrames
using Dates
using Statistics
using Printf
using PrettyTables
using Plots

# ----------------------------- Config ----------------------------------------
const ROOT_DIR   = abspath(joinpath(@__DIR__, ".."))
const CSV_FILE_NAME = "ski-regions-data.csv"
const CSV_PATH_DEFAULT = joinpath(ROOT_DIR, CSV_FILE_NAME)
const COMMAND_PREFIX = "julia --project=. bin/dach_resort_advisor"
const PLOTS_OUTPUT_DIR = joinpath(ROOT_DIR, "plots")
#---Main Logic with Saftey check---
if isfile(CSV_PATH_DEFAULT)
    println("File found at:", CSV_PATH_DEFAULT)
    println("Reading data...")
    
    df = CSV.read(CSV_PATH_DEFAULT, DataFrame)
    println("Display the first 10 rows:")
    println(first(df, 10))
else
    println("File not found!")
    println("Please ensure that the file 'ski-regions-data.csv' is located in the project directory.")

end
gr()
Plots.default(; fmt=:png, legend=:topright, size=(900, 500))

const DACH_SYNONYMS = Dict(
    "AUSTRIA" => "Austria",
    "OESTERREICH" => "Austria",
    "AT" => "Austria",
    "AUT" => "Austria",
    "GERMANY" => "Germany",
    "DEUTSCHLAND" => "Germany",
    "DE" => "Germany",
    "DEU" => "Germany",
    "SWITZERLAND" => "Switzerland",
    "SCHWEIZ" => "Switzerland",
    "CH" => "Switzerland",
    "CHE" => "Switzerland"
)

const METRIC_WEIGHT_CONFIG = (
    :snow_new => (column=Symbol("Avg Snow_New (cm)"), prompt="Frischer Schnee (Avg Snow_New cm)", env="WEIGHT_SNOW_NEW"),
    :snow_depth => (column=Symbol("Avg Snow Depth (cm)"), prompt="Schneehöhe (Avg Snow Depth cm)", env="WEIGHT_SNOW_DEPTH"),
    :temperature => (column=Symbol("Avg Temperature (°C)"), prompt="Temperatur (Avg Temperature °C)", env="WEIGHT_TEMPERATURE"),
    :precipitation => (column=Symbol("Avg Precipitation (mm)"), prompt="Niederschlag (Avg Precipitation mm)", env="WEIGHT_PRECIPITATION"),
    :wind => (column=Symbol("Avg Wind (Beaufort)"), prompt="Wind (Avg Wind Beaufort)", env="WEIGHT_WIND")
)

const DEFAULT_METRIC_WEIGHTS = Dict(
    :snow_new => 1.0,
    :snow_depth => 0.8,
    :temperature => -0.5,
    :precipitation => -0.2,
    :wind => -0.2
)

const METRIC_WEIGHT_FLAGS = Dict(
    "--weight-snow-new" => :snow_new,
    "--weight-snow-depth" => :snow_depth,
    "--weight-temperature" => :temperature,
    "--weight-precipitation" => :precipitation,
    "--weight-wind" => :wind
)

# ----------------------------- Utils -----------------------------------------
"""
    slower(x)

Return the lowercase string representation of `x` while tolerating any input type.
Used to implement case-insensitive comparisons throughout the data prep pipeline.
"""
slower(x) = lowercase(String(x))
import Base: lowercase
"""
    Base.lowercase(x::Symbol)

Overload of `lowercase` so symbols participate in the `slower` conversions without
additional calls to `String` in the call sites.
"""
lowercase(x::Symbol) = lowercase(String(x))

"""
    slugify(name)

Transform a region name into a filesystem-friendly slug used for naming plot files.
Non alphanumeric characters collapse into underscores and redundant underscores are
removed to keep filenames tidy.
"""
function slugify(name::AbstractString)
    slug = lowercase(strip(name))
    slug = replace(slug, r"[^a-z0-9]+" => "_")
    slug = replace(slug, r"_+" => "_")
    slug = strip(slug, '_')
    return slug == "" ? "region" : slug
end

"""
    ensure_plot_dir()

Create the `plots/` output directory on demand and return its absolute path. This is
called before saving any generated PNGs to guarantee the destination exists.
"""
function ensure_plot_dir()
    isdir(PLOTS_OUTPUT_DIR) || mkpath(PLOTS_OUTPUT_DIR)
    return PLOTS_OUTPUT_DIR
end

"""
    clean_numeric_series(dates, values)

Pair a date vector with numeric values while skipping missing or non-parsable entries.
Returns two aligned vectors (`Date[]`, `Float64[]`) suitable for plotting time-series
metrics.
"""
function clean_numeric_series(dates::AbstractVector, values::AbstractVector)
    xs = Date[]
    ys = Float64[]
    for (d, v) in zip(dates, values)
        if v === missing || v === nothing
            continue
        end
        val = try
            Float64(v)
        catch
            continue
        end
        if isnan(val)
            continue
        end
        push!(xs, Date(d))
        push!(ys, val)
    end
    return xs, ys
end

"""
    clone_metric_weights()

Return a fresh copy of the default metric weights dictionary so downstream callers can
mutate the map without affecting the global defaults.
"""
function clone_metric_weights()
    return Dict(key => DEFAULT_METRIC_WEIGHTS[key] for (key, _) in METRIC_WEIGHT_CONFIG)
end

"""
    parse_weight_value(raw)

Normalise user-provided weight strings by trimming whitespace, converting commas to
decimal points, and attempting to parse a `Float64`. Returns `nothing` on failure.
"""
function parse_weight_value(raw::AbstractString)
    normalized = replace(strip(raw), "," => ".")
    val = tryparse(Float64, normalized)
    return val
end

"""
    parse_bool(value)

Interpret typical boolean string forms (`"true"`, `"1"`, `"yes"`, etc.) and return
`true`/`false`, or `nothing` when the token cannot be classified.
"""
function parse_bool(value::AbstractString)
    normalized = lowercase(strip(value))
    normalized in ("1", "true", "yes", "y", "on") && return true
    normalized in ("0", "false", "no", "n", "off") && return false
    return nothing
end

"""
    apply_weight_env_overrides!(weights)

Apply environment-variable overrides (`WEIGHT_*`) to the weight dictionary in-place.
Invalid values emit warnings while leaving the current weight untouched.
"""
function apply_weight_env_overrides!(weights::Dict{Symbol,Float64})
    for (key, cfg) in METRIC_WEIGHT_CONFIG
        env_key = cfg.env
        if haskey(ENV, env_key)
            parsed = parse_weight_value(ENV[env_key])
            if parsed !== nothing
                weights[key] = parsed
            else
                @warn "Ignoring invalid weight from ENV" env_key value=ENV[env_key]
            end
        end
    end
    return weights
end

"""
    prompt_metric_weights!(weights; force=false)

Interactively collect metric weights from the user. Non-interactive sessions can set
`force=true` to display the prompt regardless of TTY detection. Inputs must be between
0 and 100 and the final sum must equal 100.
"""
function prompt_metric_weights!(weights::Dict{Symbol,Float64}; force::Bool=false)
    if !(stdin_is_tty() || force)
        println("[INFO] Gewichtungsabfrage übersprungen (nicht-interaktive Sitzung).")
        return weights
    end
    println("\n== Gewichtung der Metriken ==")
    println("Bitte für jede Metrik eine Wichtigkeit zwischen 0 und 100 eingeben. Die Summe muss 100 ergeben.")
    for (key, cfg) in METRIC_WEIGHT_CONFIG
        default = get(weights, key, 0.0)
        while true
            print("$(cfg.prompt) [$(round(default; digits=2))]: ")
            response = try
                readline()
            catch err
                isa(err, InterruptException) && rethrow()
                ""
            end
            response = strip(response)
            response == "" && break
            parsed = parse_weight_value(response)
            if parsed === nothing || parsed < 0 || parsed > 100
                println("  -> Bitte einen Wert zwischen 0 und 100 eingeben.")
                continue
            end
            weights[key] = parsed
            break
        end
    end
    total = sum(values(weights))
    if !(abs(total - 100.0) <= 1e-6)
        println("\nDie Summe der Gewichte beträgt $(round(total; digits=2)). Bitte erneut eingeben.")
        return prompt_metric_weights!(weights; force=force)
    end
    return weights
end

"""
    normalize_weights!(weights)

Scale all weight values so that their sum equals 100. When the total is non-positive,
the defaults are restored.
"""
function normalize_weights!(weights::Dict{Symbol,Float64})
    total = sum(values(weights))
    if total <= eps(Float64)
        @warn "Weight sum <= 0. Reverting to defaults." current=weights
        for (key, value) in DEFAULT_METRIC_WEIGHTS
            weights[key] = value
        end
        return weights
    end
    factor = 100.0 / total
    for (key, value) in weights
        weights[key] = value * factor
    end
    return weights
end

"""
    prepare_weights!(weights; force, prompt)

Optionally prompt the user for custom weights (honouring forced prompts for non-TTY
sessions). Returns the mutated dictionary for convenience.
"""
function prepare_weights!(weights::Dict{Symbol,Float64}; force::Bool, prompt::Bool)
    if prompt
        prompt_metric_weights!(weights; force=force)
    else
        normalize_weights!(weights)
    end
    return weights
end

"""
    add_weighted_score!(df, weights)

Compute a weighted composite metric using the provided weights and append it as the
`WeightedScore` column. Missing or constant series fall back to neutral values.
"""
function add_weighted_score!(df::DataFrame, weights::Dict{Symbol,Float64})
    isempty(df) && return df
    scores = zeros(Float64, nrow(df))
    contributed = falses(nrow(df))
    any_metric = false
    for (key, cfg) in METRIC_WEIGHT_CONFIG
        weight = get(weights, key, 0.0)
        weight == 0.0 && continue
        column = cfg.column
        column ∈ names(df) || continue
        vals = df[!, column]
        valid = collect(skipmissing(vals))
        isempty(valid) && continue
        minv = minimum(valid)
        maxv = maximum(valid)
        rangev = maxv - minv
        any_metric = true
        for (idx, raw) in enumerate(vals)
            raw === missing && continue
            v = Float64(raw)
            normalized = rangev == 0 ? 0.5 : (v - minv) / rangev
            scores[idx] += weight * normalized
            contributed[idx] = true
        end
    end
    if any_metric
        df[!, :WeightedScore] = map(eachindex(scores)) do i
            contributed[i] ? round(scores[i]; digits=3) : missing
        end
    else
        df[!, :WeightedScore] = fill(missing, nrow(df))
    end
    return df
end

"""
    find_date_column(df)

Heuristically locate the column that contains date information by scanning common
keywords (`date`, `datum`, etc.). Returns `nothing` when no suitable column exists.
"""
function find_date_column(df::DataFrame)
    cols_lower = Dict(slower(c) => Symbol(c) for c in names(df))
    for key in ("date","datum","day","tag","datetime","timestamp")
        if haskey(cols_lower, key)
            return cols_lower[key]
        end
    end
    for c in names(df)
        lc = slower(c)
        if occursin("date", lc) || occursin("datum", lc)
            return Symbol(c)
        end
    end
    return nothing
end

"""
    lininterp!(v)

Fill gaps in a numeric vector by performing linear interpolation between known values.
Leading/trailing missings copy the nearest observed neighbour.
"""
function lininterp!(v::AbstractVector{T}) where {T}
    n = length(v)
    firstidx = findfirst(!ismissing, v)
    lastidx  = findlast(!ismissing, v)
    if firstidx === nothing || lastidx === nothing
        return v
    end
    for i in 1:firstidx-1
        v[i] = v[firstidx]
    end
    for i in lastidx+1:n
        v[i] = v[lastidx]
    end
    i = firstidx
    while i <= n
        if ismissing(v[i])
            j = i
            while j <= n && ismissing(v[j])
                j += 1
            end
            left = v[i-1]; right = v[j]
            gap = j - i + 1
            for k in 0:(gap-1)
                v[i+k] = left + (right - left) * (k+1) / (gap+1)
            end
            i = j + 1
        else
            i += 1
        end
    end
    return v
end

"""
    rolling_mean(v, window)

Return a simple centred rolling mean over the numeric vector `v`. When the window is
smaller than two, the original series is returned.
"""
function rolling_mean(v::AbstractVector{T}, w::Int) where {T<:Real}
    n = length(v)
    w <= 1 && return collect(v)
    out = similar(v, Float64)
    half = cld(w, 2)
    for i in 1:n
        lo = max(1, i - half + 1)
        hi = min(n, i + half - 1)
        out[i] = mean(@view v[lo:hi])
    end
    return out
end

"""
    normalize_columns!(df)

Rename known data columns (temperature, snow, etc.) to consistent display labels so the
downstream reporting code can address them reliably.
"""
function normalize_columns!(df::DataFrame)
    ren = Dict{Symbol,Symbol}()
    for c in names(df)
        col_sym = Symbol(c)
        lc = replace(slower(c), "  " => " ")
        if occursin("elevation", lc)
            ren[col_sym] = Symbol("Elevation (m)")
        elseif occursin("wind", lc) && occursin("beaufort", lc)
            ren[col_sym] = Symbol("Wind (Beaufort)")
        elseif occursin("temp", lc)
            ren[col_sym] = Symbol("Temperature (°C)")
        elseif occursin("precip", lc) || occursin("niedersch", lc)
            ren[col_sym] = Symbol("Precipitation (mm)")
        elseif occursin("snow", lc) || occursin("schnee", lc)
            ren[col_sym] = Symbol("Snow Depth (cm)")
        elseif lc == "region"
            ren[col_sym] = :Region
        elseif lc == "country"
            ren[col_sym] = :Country
        end
    end
    rename!(df, ren)
end

# ----------------------------- Load & Prep -----------------------------------
"""
    search_for_csv(filename)

Walk the project tree to locate a CSV file by name. Used as a fallback when the file
is not found in the expected locations.
"""
function search_for_csv(filename::String)
    for (root, _, files) in walkdir(ROOT_DIR)
        if filename in files
            return joinpath(root, filename)
        end
    end
    return nothing
end

"""
    normalize_path(path)

Strip surrounding whitespace from a path string and coerce empty results to `nothing`.
This keeps CLI and ENV overrides consistent with optional argument semantics.
"""
function normalize_path(p::String)
    cp = strip(p)
    return cp == "" ? nothing : cp
end

"""
    resolve_csv_path(csv_path)

Determine the CSV file to load by checking CLI/ENV overrides, default locations, and a
recursive search. Returns an absolute path or `nothing` when nothing can be found.
"""
function resolve_csv_path(csv_path::Union{Nothing,String})
    requested = csv_path === nothing ? get(ENV, "CSV_PATH", nothing) : csv_path
    requested = requested === nothing ? nothing : normalize_path(String(requested))

    candidate_list = String[]
    if requested !== nothing
        push!(candidate_list, requested)
        push!(candidate_list, joinpath(ROOT_DIR, requested))
        if lowercase(splitext(requested)[2]) != ".csv"
            push!(candidate_list, joinpath(ROOT_DIR, CSV_FILE_NAME))
        end
    end
    push!(candidate_list, CSV_PATH_DEFAULT)
    push!(candidate_list, joinpath(ROOT_DIR, "data", CSV_FILE_NAME))

    seen = Set{String}()
    for cand in candidate_list
        c = abspath(cand)
        if c in seen
            continue
        end
        push!(seen, c)
        if isfile(c)
            return c
        end
    end

    fallback = search_for_csv(CSV_FILE_NAME)
    if fallback !== nothing
        @warn "Using fallback CSV" fallback
        return fallback
    end

    return nothing
end

"""
    load_data([csv_path])

Load the resort dataset into a `DataFrame`, normalise column names/types, and ensure
dates are sorted. Raises an error when no CSV can be located.
"""
function load_data(csv_path::Union{Nothing,String}=nothing)
    path = resolve_csv_path(csv_path)
    path === nothing && error("CSV not found. Set CSV_PATH env variable, pass a path argument, or keep $(CSV_FILE_NAME) in the project directory.")
    println("[INFO] Loading CSV: $(path)")
    df = CSV.read(path, DataFrame)
    rename!(df, Dict(c => Symbol(strip(String(c))) for c in names(df)))

    date_col = find_date_column(df)
    isnothing(date_col) && error("No date column detected. Expecting something like 'Date'.")

    df[!, date_col] = DateTime.(df[!, date_col]) .|> Date
    sort!(df, date_col)
    rename!(df, Dict(date_col => :Date))

    normalize_columns!(df)

    for c in (Symbol("Elevation (m)"), Symbol("Wind (Beaufort)"), Symbol("Temperature (°C)"), Symbol("Precipitation (mm)"), Symbol("Snow Depth (cm)"))
        if hasproperty(df, c)
            df[!, c] = map(df[!, c]) do x
                if x === missing || x === nothing
                    missing
                elseif x isa Number
                    Float64(x)
                else
                    val = tryparse(Float64, string(x))
                    isnothing(val) ? missing : val
                end
            end
        end
    end

    for c in (:Region, :Country)
        if hasproperty(df, c)
            df[!, c] = map(x -> begin
                s = strip(string(x))
                s == "" ? missing : s
            end, df[!, c])
        end
    end

    if hasproperty(df, :Country)
        df[!, :Country] = map(canonical_country, coalesce.(df[!, :Country], ""))
    end

    if hasproperty(df, Symbol("Precipitation (mm)"))
        df[!, Symbol("Precipitation (mm)")] = coalesce.(df[!, Symbol("Precipitation (mm)")], 0.0)
    end

    for c in (Symbol("Wind (Beaufort)"), Symbol("Temperature (°C)"), Symbol("Snow Depth (cm)"))
        if hasproperty(df, c)
            v = Vector{Union{Missing,Float64}}(df[!, c])
            lininterp!(v)
            df[!, c] = Float64.(coalesce.(v, NaN))
        end
    end

    return df
end

"""
    canonical_country(value)

Map various country labels (ISO codes, German spellings, etc.) to a consistent English
name. Unknown inputs pass through unchanged after trimming.
"""
function canonical_country(value)
    key = uppercase(strip(String(value)))
    get(DACH_SYNONYMS, key, strip(String(value)))
end

"""
    add_newsnow!(df)

Append a `Snow_New (cm)` column that captures day-to-day snow depth increases per
region/country grouping. Flat or negative changes become zero.
"""
function add_newsnow!(df::DataFrame)
    sn = Symbol("Snow Depth (cm)")
    if !hasproperty(df, sn)
        return df
    end
    new_col = Symbol("Snow_New (cm)")
    df[!, new_col] = fill(0.0, nrow(df))
    groupcols = intersect([:Region, :Country], names(df))
    if isempty(groupcols)
        sort!(df, :Date)
        diffs = [NaN; diff(df[!, sn])]
        df[!, new_col] = map(x -> isnan(x) ? 0.0 : max(x, 0.0), diffs)
        return df
    end
    for sub in groupby(df, groupcols)
        sort!(sub, :Date)
        diffs = [NaN; diff(sub[!, sn])]
        gains = map(x -> isnan(x) ? 0.0 : max(x, 0.0), diffs)
        df[!, new_col][sub.row .|> Int] = gains
    end
    return df
end

# ----------------------------- CLI Config ------------------------------------
"""
    RunArgs

Container for time/season filters parsed from CLI arguments or environment variables.
"""
struct RunArgs
    fromdate::Union{Nothing,Date}
    todate::Union{Nothing,Date}
    season::String
end

"""
    CLIConfig

High-level configuration for a script run, tracking the subcommand, dataset location,
filters, user-selected region, weight map, and menu-specific state.
"""
struct CLIConfig
    command::Symbol
    csv_path::Union{Nothing,String}
    runargs::RunArgs
    region_focus::Union{Nothing,String}
    weights::Dict{Symbol,Float64}
    force_weight_prompt::Bool
    menu_country::Union{Nothing,String}
end

"""
    parse_cli()

Parse CLI arguments and environment variables into a `CLIConfig`, including the active
subcommand, data path, filters, weight overrides, and menu-specific flags.
"""
function parse_cli()
    from_str = get(ENV, "FROM_DATE", nothing)
    to_str = get(ENV, "TO_DATE", nothing)
    season = uppercase(get(ENV, "SEASON", "ALL"))
    csv_path = get(ENV, "CSV_PATH", nothing)
    region_focus = get(ENV, "REGION", nothing)
    command = :menu
    weights = clone_metric_weights()
    apply_weight_env_overrides!(weights)
    force_prompt = true
    if haskey(ENV, "FORCE_WEIGHT_PROMPT")
        parsed = parse_bool(ENV["FORCE_WEIGHT_PROMPT"])
        if parsed !== nothing
            force_prompt = parsed
        else
            @warn "Ignoring invalid FORCE_WEIGHT_PROMPT env value" value=ENV["FORCE_WEIGHT_PROMPT"]
        end
    end

    i = 1
    while i <= length(ARGS)
        arg = ARGS[i]
        if arg == "report"
            command = :report
        elseif arg == "menu"
            command = :menu
        elseif arg == "list"
            command = :list
        elseif arg == "region" && i < length(ARGS)
            command = :region
            region_focus = ARGS[i+1]
            i += 1
        elseif arg == "--from" && i < length(ARGS)
            from_str = ARGS[i+1]; i += 1
        elseif arg == "--to" && i < length(ARGS)
            to_str = ARGS[i+1]; i += 1
        elseif arg == "--season" && i < length(ARGS)
            season = uppercase(ARGS[i+1]); i += 1
        elseif arg == "--csv" && i < length(ARGS)
            csv_path = ARGS[i+1]; i += 1
        elseif arg == "--ask-weights"
            force_prompt = true
        elseif arg == "--no-ask-weights"
            force_prompt = false
        elseif startswith(arg, "--weight-")
            flag = arg
            value = nothing
            if occursin('=', arg)
                parts = split(arg, "=", limit=2)
                flag = parts[1]
                value = parts[2]
            elseif i < length(ARGS)
                value = ARGS[i+1]
                i += 1
            end
            key = get(METRIC_WEIGHT_FLAGS, flag, nothing)
            if key === nothing
                @warn "Unbekannte Gewichtungsoption" arg
            elseif value === nothing
                @warn "Option $(flag) benötigt einen numerischen Wert"
            else
                parsed = parse_weight_value(value)
                if parsed === nothing
                    @warn "Gewicht konnte nicht interpretiert werden" flag value
                else
                    weights[key] = parsed
                end
            end
        elseif startswith(arg, "--")
            @warn "Unknown option" arg
        elseif csv_path === nothing
            csv_path = arg
        else
            @warn "Unrecognized argument" arg
        end
        i += 1
    end

    from_date = isnothing(from_str) ? nothing : try
        Date(from_str)
    catch
        @warn "Could not parse FROM_DATE" from_str
        nothing
    end

    to_date = isnothing(to_str) ? nothing : try
        Date(to_str)
    catch
        @warn "Could not parse TO_DATE" to_str
        nothing
    end

    normalize_weights!(weights)

    runargs = RunArgs(from_date, to_date, season)
    return CLIConfig(command, csv_path, runargs, region_focus, weights, force_prompt, nothing)
end

"""
    in_season(date, season)

Return `true` when the provided `Date` falls within the specified season keyword.
`WINTER` spans November–April, `SUMMER` May–October, and everything else accepts all.
"""
function in_season(d::Date, season::String)
    m = month(d)
    season == "WINTER" && return m in (11,12,1,2,3,4)
    season == "SUMMER" && return m in (5,6,7,8,9,10)
    return true
end

"""
    apply_filters(df, runargs)

Apply region/country/environment filters along with optional date bounds and season
restrictions, returning a filtered copy of the DataFrame.
"""
function apply_filters(df::DataFrame, rargs::RunArgs)
    region = get(ENV, "REGION", nothing)
    country = get(ENV, "COUNTRY", nothing)
    if !isnothing(region) && hasproperty(df, :Region)
        df = filter(:Region => x -> !ismissing(x) && slower(x) == slower(region), df)
    end
    if !isnothing(country) && hasproperty(df, :Country)
        df = filter(:Country => x -> !ismissing(x) && slower(x) == slower(country), df)
    end
    if rargs.fromdate !== nothing
        df = filter(:Date => d -> d >= rargs.fromdate, df)
    end
    if rargs.todate !== nothing
        df = filter(:Date => d -> d <= rargs.todate, df)
    end
    if rargs.season != "ALL"
        df = filter(:Date => d -> in_season(d, rargs.season), df)
    end
    return df
end

# ----------------------------- QC Checks -------------------------------------
"""
    qc_checks(df)

Run a series of lightweight quality checks on the filtered dataset, printing warnings
for missing days or implausible metric values.
"""
function qc_checks(df::DataFrame)
    println("\n== QC Checks ==")
    issues = false

    if all(x -> hasproperty(df, x), [:Region, :Date])
        for (grp, sub) in pairs(groupby(df, :Region))
            sort!(sub, :Date)
            dmin, dmax = sub.Date[1], sub.Date[end]
            expected = collect(dmin:Day(1):dmax)
            have = Set(sub.Date)
            missing = [d for d in expected if !(d in have)]
            if !isempty(missing)
                issues = true
                println(@sprintf("[MISSING] Region=%s: %d missing days (%s%s)", string(grp[1][2]), length(missing), join(string.(missing[1:min(end,10)]), ", "), length(missing)>10 ? ", …" : ""))
            end
        end
    end

    if hasproperty(df, Symbol("Wind (Beaufort)"))
        w = df[!, Symbol("Wind (Beaufort)")]
        n = count(>(12), w)
        if n > 0
            issues = true
            println(@sprintf("[OUTLIER] %d wind values > 12 Beaufort", n))
        end
    end
    if hasproperty(df, Symbol("Precipitation (mm)"))
        p = df[!, Symbol("Precipitation (mm)")]
        n = count(<(0), p)
        if n > 0
            issues = true
            println(@sprintf("[OUTLIER] %d negative precipitation values", n))
        end
    end
    if hasproperty(df, Symbol("Snow Depth (cm)"))
        s = df[!, Symbol("Snow Depth (cm)")]
        n = count(<(0), s)
        if n > 0
            issues = true
            println(@sprintf("[OUTLIER] %d negative snow depth values", n))
        end
    end
    if hasproperty(df, Symbol("Temperature (°C)"))
        t = df[!, Symbol("Temperature (°C)")]
        nbad = count(x -> x < -60 || x > 50, t)
        if nbad > 0
            issues = true
            println(@sprintf("[OUTLIER] %d temperature values outside [-60,50]°C", nbad))
        end
    end

    if !issues
        println("No anomalies detected.")
    end
end

# ----------------------------- Terminal Reporting ----------------------------
const HEADER_CRAYON = PrettyTables.Crayon(foreground=:cyan, bold=true)
const STRIPE_CRAYON = PrettyTables.Crayon(background=:blue)
const POSITIVE_CRAYON = PrettyTables.Crayon(foreground=:green, bold=true)
const NEGATIVE_CRAYON = PrettyTables.Crayon(foreground=:red, bold=true)

const TABLE_HIGHLIGHTERS = [
    PrettyTables.TextHighlighter((data, i, j) -> iseven(i), STRIPE_CRAYON),
    PrettyTables.TextHighlighter((data, i, j) -> data[i, j] isa Number && data[i, j] > 0, POSITIVE_CRAYON),
    PrettyTables.TextHighlighter((data, i, j) -> data[i, j] isa Number && data[i, j] < 0, NEGATIVE_CRAYON)
]

"""
    styled_table(data; kwargs...)

Wrapper around `pretty_table` that applies consistent highlighters for alternating
rows and positive/negative values across all reports.
"""
function styled_table(data; kwargs...)
    pretty_table(data; highlighters=TABLE_HIGHLIGHTERS, kwargs...)
end

"""
    available_regions(df)

Return a sorted list of distinct region names present in the dataset.
"""
function available_regions(df::DataFrame)
    if !hasproperty(df, :Region)
        return String[]
    end
    raw = [strip(string(r)) for r in skipmissing(df.Region) if strip(string(r)) != ""]
    unique!(raw)
    sort!(raw)
    return raw
end

"""
    available_countries(df)

Return a sorted list of distinct country names extracted from the dataset.
"""
function available_countries(df::DataFrame)
    if !hasproperty(df, :Country)
        return String[]
    end
    raw = [strip(string(c)) for c in skipmissing(df.Country) if strip(string(c)) != ""]
    unique!(raw)
    sort!(raw)
    return raw
end

"""
    filter_country(df, country)

Filter rows to those matching the supplied `country` (case-insensitive). When
`country === nothing`, the original DataFrame is returned.
"""
function filter_country(df::DataFrame, country::Union{Nothing,AbstractString})
    if country === nothing || !hasproperty(df, :Country)
        return df
    end
    target = slower(String(country))
    return filter(:Country => x -> !ismissing(x) && slower(String(x)) == target, df)
end

"""
    print_available_regions(regions)

Write a bullet list of region names to the terminal, with a fallback message when none
are available.
"""
function print_available_regions(regions::AbstractVector{<:AbstractString})
    println("== Available Regions ==")
    if isempty(regions)
        println(" (no regions found)")
    else
        for r in regions
            println(" - $(r)")
        end
    end
    println()
end

"""
    collect_valid(values)

Gather numeric entries from `values`, skipping missing, `nothing`, or `NaN` entries and
returning a `Vector{Float64}` for statistical processing.
"""
function collect_valid(v)
    out = Float64[]
    for x in v
        if x === missing || x === nothing
            continue
        end
        xv = try
            Float64(x)
        catch
            continue
        end
        if !isnan(xv)
            push!(out, xv)
        end
    end
    return out
end

"""
    metric_stats(values)

Build a short statistics table (count, mean, median, extrema, standard deviation) for
the provided numeric vector.
"""
function metric_stats(values::Vector{Float64})
    if isempty(values)
        return DataFrame(Statistic=String[], Value=Any[])
    end
    stats = [
        ("Count", length(values)),
        ("Mean", round(mean(values); digits=2)),
        ("Median", round(median(values); digits=2)),
        ("Minimum", round(minimum(values); digits=2)),
        ("Maximum", round(maximum(values); digits=2)),
        ("Std. Deviation", length(values) > 1 ? round(std(values); digits=2) : 0.0)
    ]
    return DataFrame(Statistic = first.(stats), Value = Any[x[2] for x in stats])
end

"""
    print_data_preview(df; limit=5)

Show the first and last `limit` rows of the DataFrame using the shared table styling,
helpful for quick sanity checks.
"""
function print_data_preview(df::DataFrame; limit::Int=5)
    rows = min(limit, nrow(df))
    println("\n== Data Preview — first $(rows) rows ==")
    styled_table(first(df, rows))
    if nrow(df) > rows
        println("\n== Data Preview — last $(rows) rows ==")
        styled_table(last(df, rows))
    end
end

"""
    current_month_subset(df)

Return the current (or latest available) month label and the DataFrame rows
belonging to that month. When the dataset lacks dates, a sentinel `(Date(0),
DataFrame())` tuple is returned.
"""
function current_month_subset(df::DataFrame)
    if !hasproperty(df, :Date) || isempty(df)
        return (Date(0), DataFrame())
    end
    today = Dates.today()
    subset = filter(:Date => d -> month(d) == month(today) && year(d) == year(today), df)
    label_date = today
    if isempty(subset)
        label_date = maximum(df.Date)
        subset = filter(:Date => d -> month(d) == month(label_date) && year(d) == year(label_date), df)
    end
    return (label_date, subset)
end

"""
    print_current_month_overview(df)

Summarise key metrics for the current (or latest) month, printing averages and
extremes where data is available, and friendly info messages otherwise.
"""
function print_current_month_overview(df::DataFrame)
    label_date, subset = current_month_subset(df)
    label = isempty(subset) ? "n/a" : string(Dates.monthname(month(label_date)), " ", year(label_date))
    println("\n== Current Month Overview — $(label) ==")
    if isempty(subset)
        println("[INFO] No data for the current or latest month.")
        return
    end
    metrics = [
        Symbol("Temperature (°C)"),
        Symbol("Snow Depth (cm)"),
        Symbol("Snow_New (cm)"),
        Symbol("Precipitation (mm)"),
        Symbol("Wind (Beaufort)")
    ]
    rows = NamedTuple{(:Metric, :Average, :Minimum, :Maximum),Tuple{String,Float64,Float64,Float64}}[]
    for metric in metrics
        if hasproperty(subset, metric)
            vals = collect_valid(subset[!, metric])
            isempty(vals) && continue
            push!(rows, (Metric=string(metric), Average=round(mean(vals); digits=2), Minimum=round(minimum(vals); digits=2), Maximum=round(maximum(vals); digits=2)))
        end
    end
    if isempty(rows)
        println("[INFO] No numeric metrics available to summarise.")
        return
    end
    styled_table(DataFrame(rows))
end

"""
    safe_stat(values, reducer)

Apply `reducer` to the numeric subset of `values`, returning `missing` when no
valid entries are present.
"""
function safe_stat(v, f::Function)
    vals = collect_valid(v)
    isempty(vals) && return missing
    return f(vals)
end

"""
    metric_group_summary(df; groupcol, ycol)

Group `df` by `groupcol` (e.g., Region or Country) and tabulate counts plus summary
statistics for the metric column `ycol`. No output is produced when prerequisites are
missing.
"""
function metric_group_summary(df::DataFrame; groupcol::Symbol, ycol::Symbol)
    if !hasproperty(df, groupcol) || !hasproperty(df, ycol)
        return
    end
    grouped = combine(groupby(df, groupcol),
        ycol => (v -> length(collect_valid(v))) => :Count,
        ycol => (v -> safe_stat(v, mean)) => :Average,
        ycol => (v -> safe_stat(v, median)) => :Median,
        ycol => (v -> safe_stat(v, minimum)) => :Min,
        ycol => (v -> safe_stat(v, maximum)) => :Max
    )
    isempty(grouped) && return
    sort!(grouped, :Average, rev=true, by=x -> x isa Missing ? -Inf : Float64(x))
    for col in (:Average, :Median, :Min, :Max)
        grouped[!, col] = map(x -> x isa Missing ? missing : round(x; digits=2), grouped[!, col])
    end
    println("\n== $(String(ycol)) — by $(String(groupcol)) ==")
    styled_table(grouped)
end

"""
    recent_conditions(df; recent_days=14)

Return a slice of the last `recent_days` observations, including available metrics and
identifying columns (`Date`, `Region`, `Country`).
"""
function recent_conditions(df::DataFrame; recent_days::Int=14)
    if isempty(df)
        return DataFrame()
    end
    start_idx = max(nrow(df) - recent_days + 1, 1)
    cols = Symbol[:Date]
    for col in (:Region, :Country)
        hasproperty(df, col) && push!(cols, col)
    end
    slice = df[start_idx:end, cols]
    for col in (Symbol("Temperature (°C)"), Symbol("Snow Depth (cm)"), Symbol("Snow_New (cm)"), Symbol("Precipitation (mm)"), Symbol("Wind (Beaufort)"))
        if hasproperty(df, col)
            slice[!, col] = df[start_idx:end, col]
        end
    end
    return slice
end

"""
    print_daily_scoreboard(df; top_n=5)

Show a snowfall leaderboard for the most recent day with data, returning the table as
a DataFrame for further processing.
"""
function print_daily_scoreboard(df::DataFrame; top_n::Int=5)
    snow_col = Symbol("Snow_New (cm)")
    if !hasproperty(df, :Date) || !hasproperty(df, snow_col)
        println("\n[INFO] Unable to build the daily snowfall leaderboard (missing required columns).")
        return DataFrame()
    end
    if isempty(df)
        println("\n[INFO] No rows available for the daily snowfall leaderboard.")
        return DataFrame()
    end
    today = Dates.today()
    day_df = filter(:Date => d -> d == today, df)
    label = "today ($(string(today)))"
    if isempty(day_df)
        latest_date = maximum(df.Date)
        day_df = filter(:Date => d -> d == latest_date, df)
        label = "latest available date ($(string(latest_date)))"
    end
    if isempty(day_df)
        println("\n[INFO] No data rows match the latest available date for the daily snowfall leaderboard.")
        return DataFrame()
    end
    day_df = copy(day_df)
    sort!(day_df, snow_col, rev=true, by=x -> x isa Missing ? -Inf : Float64(x))
    count = min(top_n, nrow(day_df))
    day_df = day_df[1:count, :]

    scoreboard = DataFrame(
        Rank = collect(1:count),
        Region = hasproperty(day_df, :Region) ? map(x -> string(x), day_df.Region) : fill("n/a", count),
        Country = hasproperty(day_df, :Country) ? map(x -> string(x), day_df.Country) : fill("n/a", count),
        Elevation = hasproperty(day_df, Symbol("Elevation (m)")) ? day_df[!, Symbol("Elevation (m)")] : fill(missing, count),
        SnowNew = day_df[!, snow_col],
        Temperature = hasproperty(day_df, Symbol("Temperature (°C)")) ? day_df[!, Symbol("Temperature (°C)")] : fill(missing, count)
    )

    scoreboard.Elevation = map(x -> x === missing || x === nothing ? missing : round(Float64(x); digits=0), scoreboard.Elevation)
    scoreboard.SnowNew = round.(coalesce.(scoreboard.SnowNew, 0.0); digits=1)
    scoreboard.Temperature = map(x -> x === missing || x === nothing ? missing : round(Float64(x); digits=1), scoreboard.Temperature)

    rename!(scoreboard, Dict(
        :Elevation => Symbol("Elevation (m)"),
        :SnowNew => Symbol("Snow_New (cm)"),
        :Temperature => Symbol("Temperature (°C)")
    ))

    println("\n== Daily Snowfall Leaderboard — $(label) ==")
    styled_table(scoreboard)
    return scoreboard
end

"""
    print_monthly_overview_for_all_regions(df; weights=DEFAULT_METRIC_WEIGHTS, display=true)

Aggregate the most recent month of data per region (and optional country), compute
summaries for the configured metrics, and add a weighted score used for ranking.
When `display` is `false`, the table is returned silently for reuse in other views.
"""
function print_monthly_overview_for_all_regions(df::DataFrame; weights::Dict{Symbol,Float64}=DEFAULT_METRIC_WEIGHTS, display::Bool=true)
    if !hasproperty(df, :Date)
        display && println("\n[INFO] No Date column available - cannot build the monthly overview.")
        return (table=DataFrame(), label="")
    end
    metrics_map = [
        (Symbol("Temperature (°C)"), Symbol("Avg Temperature (°C)")),
        (Symbol("Precipitation (mm)"), Symbol("Avg Precipitation (mm)")),
        (Symbol("Wind (Beaufort)"), Symbol("Avg Wind (Beaufort)")),
        (Symbol("Snow Depth (cm)"), Symbol("Avg Snow Depth (cm)")),
        (Symbol("Snow_New (cm)"), Symbol("Avg Snow_New (cm)"))
    ]
    available_metrics = [col for (col, _) in metrics_map if hasproperty(df, col)]
    if isempty(available_metrics)
        display && println("\n[INFO] No numeric metrics available to build the monthly overview.")
        return (table=DataFrame(), label="")
    end

    month_df = transform(copy(df), :Date => ByRow(d -> Date(year(d), month(d), 1)) => :Month)
    unique_months = unique(month_df.Month)
    if isempty(unique_months)
        display && println("\n[INFO] Monthly overview not available (no month values detected).")
        return (table=DataFrame(), label="")
    end
    focus_month = maximum(unique_months)
    month_subset = filter(:Month => m -> m == focus_month, month_df)
    if isempty(month_subset)
        display && println("\n[INFO] No rows for the monthly overview.")
        return (table=DataFrame(), label="")
    end

    group_cols = [:Region]
    if hasproperty(month_subset, :Country)
        push!(group_cols, :Country)
    end

    transformations = Any[nrow => :Observations]
    for (col, label) in metrics_map
        hasproperty(month_subset, col) || continue
        push!(transformations, col => (v -> safe_stat(v, mean)) => label)
    end

    aggregated = combine(groupby(month_subset, group_cols), transformations...)
    if isempty(aggregated)
        display && println("\n[INFO] Monthly overview could not be generated (empty grouping result).")
        return (table=DataFrame(), label="")
    end

    for col in names(aggregated)
        if col in group_cols || col == :Observations
            continue
        end
        column_data = aggregated[!, col]
        if all(x -> x === missing || x isa Number, column_data)
            aggregated[!, col] = map(x -> x === missing ? missing : round(Float64(x); digits=2), column_data)
        end
    end

    add_weighted_score!(aggregated, weights)

    sort_col = if :WeightedScore in names(aggregated) && any(x -> x !== missing, aggregated[!, :WeightedScore])
        :WeightedScore
    else
        Symbol("Avg Snow_New (cm)")
    end

    if sort_col in names(aggregated)
        sort!(aggregated, sort_col, rev=true, by=x -> x isa Missing ? -Inf : Float64(x))
    end

    month_label = Dates.format(focus_month, "yyyy-mm")
    if display
        println("\n== Monthly Overview - Regional Averages for $(month_label) ==")
        styled_table(aggregated)
    end
    return (table=aggregated, label=month_label)
end

"""
    stdin_is_tty()

Check whether standard input is attached to a terminal, accounting for platforms where
`isatty` might throw. Used to decide if interactive prompts should be shown.
"""
function stdin_is_tty()
    if isdefined(Base, :isatty)
        try
            return Base.isatty(stdin)
        catch
            return false
        end
    end
    if isdefined(Base, :Libc) && isdefined(Base.Libc, :isatty)
        try
            return Base.Libc.isatty(Base.Libc.fileno(stdin)) == 1
        catch
            return false
        end
    end
    return false
end

"""
    print_active_filters(config, df)

Print the currently active season/date/region/country filters along with dataset row
counts so users understand the scope of subsequent tables.
"""
function print_active_filters(config::CLIConfig, df::DataFrame)
    println("\n== Active Filters ==")
    rargs = config.runargs
    from_label = isnothing(rargs.fromdate) ? "open" : string(rargs.fromdate)
    to_label = isnothing(rargs.todate) ? "open" : string(rargs.todate)
    season_label = isempty(rargs.season) ? "ALL" : rargs.season
    println(" - Season: $(season_label)")
    println(" - Date range: $(from_label) -> $(to_label)")
    if config.region_focus !== nothing
        println(" - Preselected region: $(config.region_focus)")
    elseif haskey(ENV, "REGION")
        env_region = ENV["REGION"]
        println(" - Preselected region (ENV): $(env_region)")
    else
        println(" - No region preselected")
    end
    if config.menu_country !== nothing
        println(" - Country filter (menu): $(config.menu_country)")
    elseif haskey(ENV, "COUNTRY")
        println(" - Country filter (ENV): " * ENV["COUNTRY"])
    else
        println(" - No country preselected")
    end
    if !isempty(df) && hasproperty(df, :Date)
        println(" - Observations after filters: $(nrow(df)) rows, window $(string(minimum(df.Date))) - $(string(maximum(df.Date)))")
    else
        println(" - No data available after applying filters")
    end
end

"""
    print_active_weights(weights)

Print the currently normalised weights as percentages and show the sum of absolute
weights for reference.
"""
function print_active_weights(weights::Dict{Symbol,Float64})
    println("\n== Aktive Gewichte ==")
    for (key, cfg) in METRIC_WEIGHT_CONFIG
        value = get(weights, key, 0.0)
        println(" - $(cfg.prompt): $(round(value; digits=2))%")
    end
    total_abs = round(sum(abs, values(weights)); digits=2)
    println("   Summe(|Gewichte|) = $(total_abs)%")
end

"""
    prompt_region_choice(df, scoreboard, config)

Ask the user to pick a region for deeper analysis, offering suggestions from the
scoreboard or the full region list. Returns the resolved region name or `nothing`.
"""
function prompt_region_choice(df::DataFrame, scoreboard::DataFrame, config::CLIConfig)
    preselected = config.region_focus
    if preselected !== nothing && strip(String(preselected)) != ""
        return String(preselected)
    end
    !stdin_is_tty() && return nothing
    regions = available_regions(df)
    isempty(regions) && return nothing

    println("\nEnter region for a focused review (press Enter to skip):")
    suggestions = String[]
    if !isempty(scoreboard) && :Region in names(scoreboard)
        suggestions = [string(r) for r in scoreboard.Region if strip(string(r)) != ""]
    end
    if isempty(suggestions)
        suggestions = regions[1:min(length(regions), 10)]
    end
    println("Suggestions: " * join(suggestions, ", "))
    print("> ")
    try
        input = strip(readline())
        input == "" && return nothing
        actual, alternatives = resolve_region_name(df, input)
        if actual === nothing
            limit = min(length(alternatives), 5)
            if limit > 0
                println("Region not found. Suggestions: " * join(alternatives[1:limit], ", "))
            else
                println("Region not found. Use `list` to see all locations.")
            end
            return nothing
        end
        return actual
    catch err
        isa(err, InterruptException) && rethrow()
        println("Input could not be processed (" * string(err) * ").")
        return nothing
    end
end

"""
    prompt_country_choice(df)

Interactively prompt the user to select one of the available countries, returning the
chosen name as a string or `nothing` when the input is blank or cancelled.
"""
function prompt_country_choice(df::DataFrame)
    countries = available_countries(df)
    if isempty(countries)
        println("[INFO] Keine Länderinformation im Datensatz verfügbar.")
        return nothing
    end
    println("\nVerfügbare Länder:")
    for (idx, country) in enumerate(countries)
        println(" $(idx)) $(country)")
    end
    println("Wähle eine Nummer oder gib den Ländernamen ein (leer für alle Länder).")
    while true
        print("> ")
        input = try
            strip(readline())
        catch err
            isa(err, InterruptException) && rethrow()
            println("[INFO] Eingabe abgebrochen: " * string(err))
            return nothing
        end
        input == "" && return nothing
        parsed_idx = tryparse(Int, input)
        if parsed_idx !== nothing && 1 <= parsed_idx <= length(countries)
            return String(countries[parsed_idx])
        end
        idx = findfirst(c -> slower(c) == slower(input), countries)
        if idx !== nothing
            return String(countries[idx])
        end
        println("Nicht erkannt. Bitte Nummer oder Namen erneut eingeben (Enter für Abbruch).")
    end
end

"""
    print_decision_hints(scoreboard, monthly_table, weights)

Derive narrative tips from the current leaderboard and weighted monthly overview,
pointing users toward notable regions (powder, calm wind, precipitation extremes).
"""
function print_decision_hints(scoreboard::DataFrame, monthly_table::DataFrame, weights::Dict{Symbol,Float64})
    println("\n== Decision Support ==")
    hints = String[]
    if !isempty(scoreboard) && all(col -> col in names(scoreboard), [Symbol("Region"), Symbol("Snow_New (cm)")])
        top_row = scoreboard[1, :]
        snow_val = top_row[Symbol("Snow_New (cm)")]
        snow_label = (snow_val === missing || snow_val === nothing) ? "" : string(round(Float64(snow_val); digits=1)) * " cm"
        push!(hints, "Fresh powder in $(top_row.Region) $(snow_label)")
    end

    if :WeightedScore in names(monthly_table)
        best_idx = nothing
        best_score = -Inf
        for (idx, score) in enumerate(monthly_table[!, :WeightedScore])
            if score === missing
                continue
            end
            if score > best_score
                best_score = score
                best_idx = idx
            end
        end
        if best_idx !== nothing
            region_name = monthly_table[best_idx, :Region]
            region_name !== missing && push!(hints, @sprintf("Beste Gesamtwertung: %s (Score %.2f)", string(region_name), best_score))
        end
    end

    function best_hint(df::DataFrame, col::Symbol; rev::Bool=false, label::String="", unit::String="")
        col ∈ names(df) || return nothing
        vals = collect(skipmissing(df[!, col]))
        isempty(vals) && return nothing
        target = (rev ? maximum(vals) : minimum(vals))
        idx = findfirst(x -> x !== missing && isapprox(x, target; atol=1e-6), df[!, col])
        idx === nothing && return nothing
        region = df[idx, :Region]
        if region === missing || strip(string(region)) == ""
            return nothing
        end
        return "$(label): $(region) (avg $(round(target; digits=2))$(unit))"
    end

    cold_hint = best_hint(monthly_table, Symbol("Avg Temperature (°C)"); label="Coldest regions", unit="°C")
    cold_hint !== nothing && push!(hints, cold_hint)

    calm_hint = best_hint(monthly_table, Symbol("Avg Wind (Beaufort)"); label="Calmest wind spots", unit=" Bft")
    calm_hint !== nothing && push!(hints, calm_hint)

    wettest_hint = best_hint(monthly_table, Symbol("Avg Precipitation (mm)"); rev=true, label="Highest precipitation", unit=" mm")
    wettest_hint !== nothing && push!(hints, wettest_hint)

    if isempty(hints)
        println("No quick suggestions available - please adjust filters.")
    else
        for h in hints
            println(" - " * h)
        end
    end
end

"""
    print_region_history(df, region_name; months=12)

Display per-month averages and totals for the chosen region across the past `months`
period, offering historical context in the regional deep dive view.
"""
function print_region_history(df::DataFrame, region_name::Union{Nothing,AbstractString}; months::Int=12)
    if isnothing(region_name)
        return
    end
    if !hasproperty(df, :Date) || isempty(df)
        println("\n[INFO] No data available for region $(region_name). Adjust filters or check the region name.")
        return
    end
    region_df = hasproperty(df, :Region) ? filter(:Region => x -> !ismissing(x) && slower(x) == slower(region_name), df) : df
    if isempty(region_df)
        println("\n[INFO] No data available for region $(region_name). Adjust filters or check the region name.")
        return
    end
    latest = maximum(region_df.Date)
    month_start = Date(year(latest), month(latest), 1)
    cutoff = month_start - Month(months - 1)
    recent_df = filter(:Date => d -> d >= cutoff, region_df)
    if isempty(recent_df)
        recent_df = region_df
    end

    month_df = transform(recent_df, :Date => ByRow(d -> Date(year(d), month(d), 1)) => :Month)
    grouped = combine(groupby(month_df, :Month),
        Symbol("Temperature (°C)") => (v -> safe_stat(v, mean)) => :AvgTemperature,
        Symbol("Snow Depth (cm)") => (v -> safe_stat(v, mean)) => :AvgSnowDepth,
        Symbol("Snow_New (cm)") => (v -> sum(collect_valid(v))) => :TotalNewSnow,
        Symbol("Precipitation (mm)") => (v -> safe_stat(v, mean)) => :AvgPrecipitation,
        Symbol("Wind (Beaufort)") => (v -> safe_stat(v, mean)) => :AvgWind
    )

    if isempty(grouped)
        println("\n[INFO] No monthly aggregates available for region $(region_name).")
        return
    end

    sort!(grouped, :Month)
    grouped.Month = Dates.format.(grouped.Month, "yyyy-mm")
    for col in (:AvgTemperature, :AvgSnowDepth, :TotalNewSnow, :AvgPrecipitation, :AvgWind)
        if col in names(grouped)
            grouped[!, col] = map(x -> x isa Missing ? missing : round(x; digits=2), grouped[!, col])
        end
    end

    rename!(grouped, Dict(
        :AvgTemperature => Symbol("Avg Temperature (°C)"),
        :AvgSnowDepth => Symbol("Avg Snow Depth (cm)"),
        :TotalNewSnow => Symbol("Total New Snow (cm)"),
        :AvgPrecipitation => Symbol("Avg Precipitation (mm)"),
        :AvgWind => Symbol("Avg Wind (Beaufort)")
    ))

    println("\n== Region Insights — $(region_name) (last $(months) months) ==")
    styled_table(grouped)
end

"""
    region_top_snow_events(df; top_n=5)

Return the top `top_n` snowfall gain days for a region, including associated snow
depth and temperature where available.
"""
function region_top_snow_events(df::DataFrame; top_n::Int=5)
    col = Symbol("Snow_New (cm)")
    if !hasproperty(df, col)
        return DataFrame()
    end
    slice = DataFrame(:Date => df[!, :Date], col => df[!, col])
    if hasproperty(df, Symbol("Snow Depth (cm)"))
        slice[!, Symbol("Snow Depth (cm)")] = df[!, Symbol("Snow Depth (cm)")]
    end
    if hasproperty(df, Symbol("Temperature (°C)"))
        slice[!, Symbol("Temperature (°C)")] = df[!, Symbol("Temperature (°C)")]
    end
    slice = filter(row -> !ismissing(row[col]) && row[col] > 0, slice)
    if isempty(slice)
        return DataFrame()
    end
    sort!(slice, col, rev=true)
    return slice[1:min(top_n, nrow(slice)), :]
end

"""
    save_region_snow_plot(region_df, region_name; recent_days=90)

Plot snow depth (line) and new snow (bars) for `recent_days` of data and save the chart
to `plots/<slug>_snow_trend.png`. Returns the generated filepath or `nothing` when
plotting is skipped.
"""
function save_region_snow_plot(region_df::DataFrame, region_name::AbstractString; recent_days::Int=90)
    required_cols = (:Date, Symbol("Snow Depth (cm)"))
    if any(col -> !hasproperty(region_df, col), required_cols)
        return nothing
    end

    local_df = sort(copy(region_df), :Date)
    if recent_days > 0 && nrow(local_df) > recent_days
        local_df = local_df[end - recent_days + 1:end, :]
    end
    isempty(local_df) && return nothing

    dates = local_df[!, :Date]
    depth_dates, depth_values = clean_numeric_series(dates, local_df[!, Symbol("Snow Depth (cm)")])
    isempty(depth_values) && return nothing

    plot_obj = plot(depth_dates, depth_values;
        label="Snow depth (cm)",
        color=:dodgerblue,
        linewidth=2,
        xlabel="Date",
        ylabel="Centimetres",
        title="$(region_name) — snow trend",
        background_color=:white)

    new_col = Symbol("Snow_New (cm)")
    if hasproperty(local_df, new_col)
        new_dates, new_values = clean_numeric_series(dates, local_df[!, new_col])
        if !isempty(new_values)
            plot!(plot_obj, new_dates, new_values;
                seriestype=:bar,
                label="Daily new snow (cm)",
                color=:lightskyblue,
                alpha=0.45,
                bar_width=0.6)
        end
    end

    ensure_plot_dir()
    filename = slugify(region_name) * "_snow_trend.png"
    out_path = joinpath(PLOTS_OUTPUT_DIR, filename)
    savefig(plot_obj, out_path)
    return out_path
end

"""
    print_available_commands()

Print the supported CLI commands along with helpful example invocations and relevant
environment variables.
"""
function print_available_commands()
    println()
    printstyled("Available commands\n"; color=:cyan, bold=true)
    printstyled("  menu          "; color=:green, bold=true); println("- interactive terminal menu")
    printstyled("  report        "; color=:green, bold=true); println("- default full dashboard (this view)")
    printstyled("  list          "; color=:green, bold=true); println("- list all DACH regions")
    printstyled("  region NAME   "; color=:green, bold=true); println("- deep dive into a single resort (replace NAME)")
    println()
    printstyled("Options:"; color=:yellow, bold=true); println(" --from YYYY-MM-DD | --to YYYY-MM-DD | --season WINTER|SUMMER|ALL")
    printstyled("Weights:"; color=:yellow, bold=true); println(" --weight-snow-new <v> | --weight-temperature <v> | ... (Prompt via --ask-weights)")
    printstyled("Environment:"; color=:yellow, bold=true); println(" REGION, CSV_PATH, WEIGHT_SNOW_NEW, ...")
    println()
    printstyled("Quick copy:"; color=:magenta, bold=true); println(" $(COMMAND_PREFIX) menu")
    printstyled("Region example:"; color=:magenta, bold=true); println(" $(COMMAND_PREFIX) region \"Zermatt\"")
end

"""
    build_report_config(base; weights, country=nothing)

Produce a `CLIConfig` tailored for report execution, optionally pinning a menu-selected
country while preserving other settings from `base`.
"""
function build_report_config(base::CLIConfig; weights::Dict{Symbol,Float64}, country::Union{Nothing,String}=nothing)
    return CLIConfig(:report, base.csv_path, base.runargs, base.region_focus, weights, base.force_weight_prompt, country)
end

"""
    run_menu(df, config)

Drive the interactive main menu, letting users start the report for all countries,
filter by a chosen country, or exit the application.
"""
function run_menu(df::DataFrame, config::CLIConfig)
    base_weights = deepcopy(config.weights)
    while true
        weights = deepcopy(base_weights)
        println("\n==== DACH Resort Advisor Menu ====")
        println("1) Start (alle Länder)")
        println("2) Land wählen und starten")
        println("q) Quit")
        print("> ")
        choice = try
            lowercase(strip(readline()))
        catch err
            isa(err, InterruptException) && rethrow()
            println("[INFO] Input aborted: " * string(err))
            return
        end
        if choice in ("1", "s", "start")
            prepare_weights!(weights; force=config.force_weight_prompt, prompt=true)
            report_config = build_report_config(config; weights=weights)
            run_report(df, report_config, weights)
            base_weights = deepcopy(weights)
        elseif choice in ("2", "l", "land")
            country = prompt_country_choice(df)
            if country === nothing
                println("[INFO] Kein Land ausgewählt – zeige alle Länder.")
                report_config = build_report_config(config; weights=weights)
                run_report(df, report_config, weights)
                continue
            end
            filtered = filter_country(df, country)
            if isempty(filtered)
                println("[INFO] Keine Daten für $(country) vorhanden.")
                continue
            end
            prepare_weights!(weights; force=config.force_weight_prompt, prompt=true)
            local_config = build_report_config(config; weights=weights, country=country)
            run_report(filtered, local_config, weights)
            base_weights = deepcopy(weights)
        elseif choice in ("q", "quit", "exit")
            println("Auf Wiedersehen!")
            return
        elseif choice == ""
            println("Bitte eine Option wählen (Start oder Quit).")
        else
            println("Unbekannte Auswahl: $(choice)")
        end
    end
end

"""
    run_report(df, config, weights)

Drive the primary reporting workflow: display filters and weights, show leaderboards
and monthly aggregates, prompt for a region deep dive, and optionally extend with
detailed analytics.
"""
function run_report(df::DataFrame, config::CLIConfig, weights::Dict{Symbol,Float64})
    print_active_filters(config, df)
    print_active_weights(weights)

    scoreboard = print_daily_scoreboard(df; top_n=10)
    monthly = print_monthly_overview_for_all_regions(df; weights=weights)
    print_decision_hints(scoreboard, monthly.table, weights)

    selected_region = prompt_region_choice(df, scoreboard, config)
    if selected_region !== nothing
        run_region(df, selected_region; weights=weights, monthly_table=monthly.table)
    else
        println("\nTip: use `list` to see every region or `region <NAME>` for an immediate deep dive.")
    end

    show_full = !stdin_is_tty()
    if stdin_is_tty()
        println("\nShow extended analytics? (y/N)")
        print("> ")
        response = try
            lowercase(strip(readline()))
        catch err
            isa(err, InterruptException) && rethrow()
            ""
        end
        show_full = response in ("y", "yes", "j", "ja")
    end

    if show_full
        println("\n== Extended Data Views ==")
        if nrow(df) > 0 && hasproperty(df, :Date)
            println(@sprintf("Dataset after filters: %d rows, %d columns (%s - %s)", nrow(df), ncol(df), string(minimum(df.Date)), string(maximum(df.Date))))
        else
            println("Dataset after filters: 0 rows.")
        end

        qc_checks(df)

        for ycol in (Symbol("Temperature (°C)"), Symbol("Wind (Beaufort)"), Symbol("Precipitation (mm)"), Symbol("Snow Depth (cm)"), Symbol("Snow_New (cm)"))
            metric_group_summary(df; groupcol=:Region, ycol=ycol)
            metric_group_summary(df; groupcol=:Country, ycol=ycol)
        end
    else
        println("\nQuick overview finished. Rerun the tool with specific filters (e.g. `--season WINTER` or `REGION=Verbier`) for deeper insights.")
    end
end

"""
    run_list(df)

Print the alphabetised list of regions present in the dataset.
"""
function run_list(df::DataFrame)
    print_available_regions(available_regions(df))
end

"""
    resolve_region_name(df, name)

Resolve a user-supplied region string to an exact dataset entry, returning the match
and a list of suggestions when no exact hit is found.
"""
function resolve_region_name(df::DataFrame, name::AbstractString)
    regs = available_regions(df)
    target = slower(name)
    for r in regs
        if slower(r) == target
            return (r, String[])
        end
    end
    suggestions = [r for r in regs if occursin(target, slower(r))]
    return (nothing, suggestions)
end

"""
    run_region(df, region_name; weights=DEFAULT_METRIC_WEIGHTS, monthly_table=nothing)

Render the region deep dive, including high-level metadata, monthly summaries, recent
conditions, historical aggregates, and plot generation for the chosen region.
"""
function run_region(df::DataFrame, region_name::Union{Nothing,String}; weights::Dict{Symbol,Float64}=DEFAULT_METRIC_WEIGHTS, monthly_table::Union{Nothing,DataFrame}=nothing)
    if region_name === nothing || strip(String(region_name)) == ""
        println("Please provide a region name, e.g. `$(COMMAND_PREFIX) region \"Zermatt\"`.")
        run_list(df)
        return
    end

    actual, suggestions = resolve_region_name(df, String(region_name))
    if actual === nothing
        println("Region \"$(region_name)\" not found.")
        if !isempty(suggestions)
            println("Did you mean: " * join(suggestions[1:min(5, length(suggestions))], ", ") * "?")
        end
        println("Run `list` to show all available regions.")
        return
    end

    region_df = filter(:Region => x -> !ismissing(x) && slower(String(x)) == slower(actual), df)
    if isempty(region_df)
        println("No data available for region $(actual) after applying filters.")
        return
    end

    country = hasproperty(region_df, :Country) ? unique([string(c) for c in region_df.Country if c !== missing]) : String[]
    country_label = isempty(country) ? "Unknown" : country[1]

    println("== Region Overview — $(actual) ==")
    println(@sprintf("Country: %s | Observations: %d | Date range: %s to %s", country_label, nrow(region_df), string(minimum(region_df.Date)), string(maximum(region_df.Date))))
    if monthly_table === nothing
        print_active_weights(weights)
    end

    print_current_month_overview(region_df)
    events = region_top_snow_events(region_df; top_n=5)
    if !isempty(events)
        println("\n== Top fresh snow days ==")
        styled_table(events)
    end

    recent = recent_conditions(region_df; recent_days=14)
    if !isempty(recent)
        println("\n== Recent conditions (last 14 days) ==")
        styled_table(recent)
    end

    print_region_history(region_df, actual; months=12)

    plot_path = nothing
    plot_ok = true
    try
        plot_path = save_region_snow_plot(region_df, actual; recent_days=120)
    catch err
        plot_ok = false
        @warn "Unable to save snow trend plot" region=actual exception=(err, catch_backtrace())
    end
    if plot_path !== nothing
        println("\n[INFO] Snow trend plot saved to: $(plot_path)")
    elseif plot_ok
        println("\n[INFO] Snow trend plot skipped (missing numeric data).")
    end

    score_source = monthly_table
    if score_source === nothing
        monthly_result = print_monthly_overview_for_all_regions(df; weights=weights, display=false)
        score_source = monthly_result.table
    end
    if score_source isa DataFrame && !isempty(score_source) && :Region in names(score_source) && :WeightedScore in names(score_source)
        idx = findfirst(1:nrow(score_source)) do i
            region_value = score_source[i, :Region]
            region_value === missing && return false
            return slower(String(region_value)) == slower(actual)
        end
        if idx !== nothing
            score_val = score_source[idx, :WeightedScore]
            score_val !== missing && println(@sprintf("[INFO] Gewichteter Score (aktuelle Gewichte): %.2f", Float64(score_val)))
        end
    end
end

# ----------------------------- Main ------------------------------------------
"""
    main()

Top-level entry point: assemble the CLI configuration, load data, apply filters, and
dispatch to the appropriate subcommand before printing closing guidance.
"""
function main()
    config = parse_cli()
    df = load_data(config.csv_path)
    add_newsnow!(df)
    df = apply_filters(df, config.runargs)

    if isempty(df)
        println("No data available after applying filters.")
        print_available_commands()
        return
    end

    weights = config.weights
    if config.command in (:report, :region)
        prepare_weights!(weights; force=config.force_weight_prompt, prompt=true)
    end

    if config.command == :list
        run_list(df)
    elseif config.command == :region
        run_region(df, config.region_focus; weights=weights)
    elseif config.command == :menu
        run_menu(df, CLIConfig(:menu, config.csv_path, config.runargs, config.region_focus, weights, config.force_weight_prompt, nothing))
    else
        run_report(df, config, weights)
    end

    println("\nDone. Terminal reporting finished.")
    print_available_commands()
end

main()
