# ===============
# DACH Resort Advisor - Seasonal Insights (Julia)
# ===============
# One-file script that:
# 1) Loads `ski-regions-data.csv` and normalizes columns
# 2) Computes New Snow (Snow_New (cm))
# 3) Filters by date range or ski season
# 4) Runs QC checks and prints warnings
# 5) Prints key figures and tabular overviews directly in the terminal
# 6) Optional: grouped tables per Region/Country for every metric
#
# Install deps once:
#   import Pkg
#   Pkg.add(["CSV","DataFrames","Dates","Statistics","Printf","PrettyTables"])
#
# Run:
#   julia --project=. bin/dach_resort_advisor
#   # with explicit CSV path:
#   julia --project=. bin/dach_resort_advisor /path/to/ski-regions-data.csv
#
# Filters via CLI args or ENV:
#   --from YYYY-MM-DD  --to YYYY-MM-DD   (ENV: FROM_DATE / TO_DATE)
#   --season WINTER|SUMMER|ALL           (ENV: SEASON)
#   REGION=Tirol COUNTRY=AT julia --project=. bin/dach_resort_advisor
#
# Season definitions (by month):
#   WINTER = Nov–Apr (11,12,1,2,3,4) | SUMMER = May–Oct (5..10)

using CSV
using DataFrames
using Dates
using Statistics
using Printf
using PrettyTables

# ----------------------------- Config ----------------------------------------
const ROOT_DIR   = abspath(joinpath(@__DIR__, ".."))
const CSV_FILE_NAME = "ski-regions-data.csv"
const CSV_PATH_DEFAULT = joinpath(ROOT_DIR, CSV_FILE_NAME)
const ROLLING_DAYS = 7
const COMMAND_PREFIX = "julia --project=. bin/dach_resort_advisor"

const DACH_SYNONYMS = Dict(
    "AUSTRIA" => "Austria",
    "OESTERREICH" => "Austria",
    "AT" => "Austria",
    "AUT" => "Austria",
    "GERMANY" => "Germany",
    "DEUTSCHLAND" => "Germany",
    "DE" => "Germany",
    "DEU" => "Germany",
    "SWITZERLAND" => "Switzerland",
    "SCHWEIZ" => "Switzerland",
    "CH" => "Switzerland",
    "CHE" => "Switzerland"
)

# ----------------------------- Utils -----------------------------------------
slower(x) = lowercase(String(x))
import Base: lowercase
lowercase(x::Symbol) = lowercase(String(x))

function find_date_column(df::DataFrame)
    cols_lower = Dict(slower(c) => Symbol(c) for c in names(df))
    for key in ("date","datum","day","tag","datetime","timestamp")
        if haskey(cols_lower, key)
            return cols_lower[key]
        end
    end
    for c in names(df)
        lc = slower(c)
        if occursin("date", lc) || occursin("datum", lc)
            return Symbol(c)
        end
    end
    return nothing
end

function lininterp!(v::AbstractVector{T}) where {T}
    n = length(v)
    firstidx = findfirst(!ismissing, v)
    lastidx  = findlast(!ismissing, v)
    if firstidx === nothing || lastidx === nothing
        return v
    end
    for i in 1:firstidx-1
        v[i] = v[firstidx]
    end
    for i in lastidx+1:n
        v[i] = v[lastidx]
    end
    i = firstidx
    while i <= n
        if ismissing(v[i])
            j = i
            while j <= n && ismissing(v[j])
                j += 1
            end
            left = v[i-1]; right = v[j]
            gap = j - i + 1
            for k in 0:(gap-1)
                v[i+k] = left + (right - left) * (k+1) / (gap+1)
            end
            i = j + 1
        else
            i += 1
        end
    end
    return v
end

function rolling_mean(v::AbstractVector{T}, w::Int) where {T<:Real}
    n = length(v)
    w <= 1 && return collect(v)
    out = similar(v, Float64)
    half = cld(w, 2)
    for i in 1:n
        lo = max(1, i - half + 1)
        hi = min(n, i + half - 1)
        out[i] = mean(@view v[lo:hi])
    end
    return out
end

function normalize_columns!(df::DataFrame)
    ren = Dict{Symbol,Symbol}()
    for c in names(df)
        col_sym = Symbol(c)
        lc = replace(slower(c), "  " => " ")
        if occursin("elevation", lc)
            ren[col_sym] = Symbol("Elevation (m)")
        elseif occursin("wind", lc) && occursin("beaufort", lc)
            ren[col_sym] = Symbol("Wind (Beaufort)")
        elseif occursin("temp", lc)
            ren[col_sym] = Symbol("Temperature (°C)")
        elseif occursin("precip", lc) || occursin("niedersch", lc)
            ren[col_sym] = Symbol("Precipitation (mm)")
        elseif occursin("snow", lc) || occursin("schnee", lc)
            ren[col_sym] = Symbol("Snow Depth (cm)")
        elseif lc == "region"
            ren[col_sym] = :Region
        elseif lc == "country"
            ren[col_sym] = :Country
        end
    end
    rename!(df, ren)
end

# ----------------------------- Load & Prep -----------------------------------
function search_for_csv(filename::String)
    for (root, _, files) in walkdir(ROOT_DIR)
        if filename in files
            return joinpath(root, filename)
        end
    end
    return nothing
end

function normalize_path(p::String)
    cp = strip(p)
    return cp == "" ? nothing : cp
end

function resolve_csv_path(csv_path::Union{Nothing,String})
    requested = csv_path === nothing ? get(ENV, "CSV_PATH", nothing) : csv_path
    requested = requested === nothing ? nothing : normalize_path(String(requested))

    candidate_list = String[]
    if requested !== nothing
        push!(candidate_list, requested)
        push!(candidate_list, joinpath(ROOT_DIR, requested))
        if lowercase(splitext(requested)[2]) != ".csv"
            push!(candidate_list, joinpath(ROOT_DIR, CSV_FILE_NAME))
        end
    end
    push!(candidate_list, CSV_PATH_DEFAULT)
    push!(candidate_list, joinpath(ROOT_DIR, "data", CSV_FILE_NAME))

    seen = Set{String}()
    for cand in candidate_list
        c = abspath(cand)
        if c in seen
            continue
        end
        push!(seen, c)
        if isfile(c)
            return c
        end
    end

    fallback = search_for_csv(CSV_FILE_NAME)
    if fallback !== nothing
        @warn "Using fallback CSV" fallback
        return fallback
    end

    return nothing
end

function load_data(csv_path::Union{Nothing,String}=nothing)
    path = resolve_csv_path(csv_path)
    path === nothing && error("CSV not found. Set CSV_PATH env variable, pass a path argument, or keep $(CSV_FILE_NAME) in the project directory.")
    println("[INFO] Loading CSV: $(path)")
    df = CSV.read(path, DataFrame)
    rename!(df, Dict(c => Symbol(strip(String(c))) for c in names(df)))

    date_col = find_date_column(df)
    isnothing(date_col) && error("No date column detected. Expecting something like 'Date'.")

    df[!, date_col] = DateTime.(df[!, date_col]) .|> Date
    sort!(df, date_col)
    rename!(df, Dict(date_col => :Date))

    normalize_columns!(df)

    for c in (Symbol("Elevation (m)"), Symbol("Wind (Beaufort)"), Symbol("Temperature (°C)"), Symbol("Precipitation (mm)"), Symbol("Snow Depth (cm)"))
        if hasproperty(df, c)
            df[!, c] = map(df[!, c]) do x
                if x === missing || x === nothing
                    missing
                elseif x isa Number
                    Float64(x)
                else
                    val = tryparse(Float64, string(x))
                    isnothing(val) ? missing : val
                end
            end
        end
    end

    for c in (:Region, :Country)
        if hasproperty(df, c)
            df[!, c] = map(x -> begin
                s = strip(string(x))
                s == "" ? missing : s
            end, df[!, c])
        end
    end

    if hasproperty(df, :Country)
        df[!, :Country] = map(canonical_country, coalesce.(df[!, :Country], ""))
    end

    if hasproperty(df, Symbol("Precipitation (mm)"))
        df[!, Symbol("Precipitation (mm)")] = coalesce.(df[!, Symbol("Precipitation (mm)")], 0.0)
    end

    for c in (Symbol("Wind (Beaufort)"), Symbol("Temperature (°C)"), Symbol("Snow Depth (cm)"))
        if hasproperty(df, c)
            v = Vector{Union{Missing,Float64}}(df[!, c])
            lininterp!(v)
            df[!, c] = Float64.(coalesce.(v, NaN))
        end
    end

    return df
end

function canonical_country(value)
    key = uppercase(strip(String(value)))
    get(DACH_SYNONYMS, key, strip(String(value)))
end

function add_newsnow!(df::DataFrame)
    sn = Symbol("Snow Depth (cm)")
    if !hasproperty(df, sn)
        return df
    end
    new_col = Symbol("Snow_New (cm)")
    df[!, new_col] = fill(0.0, nrow(df))
    groupcols = intersect([:Region, :Country], names(df))
    if isempty(groupcols)
        sort!(df, :Date)
        diffs = [NaN; diff(df[!, sn])]
        df[!, new_col] = map(x -> isnan(x) ? 0.0 : max(x, 0.0), diffs)
        return df
    end
    for sub in groupby(df, groupcols)
        sort!(sub, :Date)
        diffs = [NaN; diff(sub[!, sn])]
        gains = map(x -> isnan(x) ? 0.0 : max(x, 0.0), diffs)
        df[!, new_col][sub.row .|> Int] = gains
    end
    return df
end

# ----------------------------- CLI Config ------------------------------------
struct RunArgs
    fromdate::Union{Nothing,Date}
    todate::Union{Nothing,Date}
    season::String
end

struct CLIConfig
    command::Symbol
    csv_path::Union{Nothing,String}
    runargs::RunArgs
    region_focus::Union{Nothing,String}
end

function parse_cli()
    from_str = get(ENV, "FROM_DATE", nothing)
    to_str = get(ENV, "TO_DATE", nothing)
    season = uppercase(get(ENV, "SEASON", "ALL"))
    csv_path = get(ENV, "CSV_PATH", nothing)
    region_focus = get(ENV, "REGION", nothing)
    command = :report

    i = 1
    while i <= length(ARGS)
        arg = ARGS[i]
        if arg == "report"
            command = :report
        elseif arg == "list"
            command = :list
        elseif arg == "region" && i < length(ARGS)
            command = :region
            region_focus = ARGS[i+1]
            i += 1
        elseif arg == "--from" && i < length(ARGS)
            from_str = ARGS[i+1]; i += 1
        elseif arg == "--to" && i < length(ARGS)
            to_str = ARGS[i+1]; i += 1
        elseif arg == "--season" && i < length(ARGS)
            season = uppercase(ARGS[i+1]); i += 1
        elseif arg == "--csv" && i < length(ARGS)
            csv_path = ARGS[i+1]; i += 1
        elseif startswith(arg, "--")
            @warn "Unknown option" arg
        elseif csv_path === nothing
            csv_path = arg
        else
            @warn "Unrecognized argument" arg
        end
        i += 1
    end

    from_date = isnothing(from_str) ? nothing : try
        Date(from_str)
    catch
        @warn "Could not parse FROM_DATE" from_str
        nothing
    end

    to_date = isnothing(to_str) ? nothing : try
        Date(to_str)
    catch
        @warn "Could not parse TO_DATE" to_str
        nothing
    end

    runargs = RunArgs(from_date, to_date, season)
    return CLIConfig(command, csv_path, runargs, region_focus)
end

function in_season(d::Date, season::String)
    m = month(d)
    season == "WINTER" && return m in (11,12,1,2,3,4)
    season == "SUMMER" && return m in (5,6,7,8,9,10)
    return true
end

function apply_filters(df::DataFrame, rargs::RunArgs)
    region = get(ENV, "REGION", nothing)
    country = get(ENV, "COUNTRY", nothing)
    if !isnothing(region) && hasproperty(df, :Region)
        df = filter(:Region => x -> !ismissing(x) && slower(x) == slower(region), df)
    end
    if !isnothing(country) && hasproperty(df, :Country)
        df = filter(:Country => x -> !ismissing(x) && slower(x) == slower(country), df)
    end
    if rargs.fromdate !== nothing
        df = filter(:Date => d -> d >= rargs.fromdate, df)
    end
    if rargs.todate !== nothing
        df = filter(:Date => d -> d <= rargs.todate, df)
    end
    if rargs.season != "ALL"
        df = filter(:Date => d -> in_season(d, rargs.season), df)
    end
    return df
end

# ----------------------------- QC Checks -------------------------------------
function qc_checks(df::DataFrame)
    println("\n== QC Checks ==")
    issues = false

    if all(x -> hasproperty(df, x), [:Region, :Date])
        for (grp, sub) in pairs(groupby(df, :Region))
            sort!(sub, :Date)
            dmin, dmax = sub.Date[1], sub.Date[end]
            expected = collect(dmin:Day(1):dmax)
            have = Set(sub.Date)
            missing = [d for d in expected if !(d in have)]
            if !isempty(missing)
                issues = true
                println(@sprintf("[MISSING] Region=%s: %d missing days (%s%s)", string(grp[1][2]), length(missing), join(string.(missing[1:min(end,10)]), ", "), length(missing)>10 ? ", …" : ""))
            end
        end
    end

    if hasproperty(df, Symbol("Wind (Beaufort)"))
        w = df[!, Symbol("Wind (Beaufort)")]
        n = count(>(12), w)
        if n > 0
            issues = true
            println(@sprintf("[OUTLIER] %d wind values > 12 Beaufort", n))
        end
    end
    if hasproperty(df, Symbol("Precipitation (mm)"))
        p = df[!, Symbol("Precipitation (mm)")]
        n = count(<(0), p)
        if n > 0
            issues = true
            println(@sprintf("[OUTLIER] %d negative precipitation values", n))
        end
    end
    if hasproperty(df, Symbol("Snow Depth (cm)"))
        s = df[!, Symbol("Snow Depth (cm)")]
        n = count(<(0), s)
        if n > 0
            issues = true
            println(@sprintf("[OUTLIER] %d negative snow depth values", n))
        end
    end
    if hasproperty(df, Symbol("Temperature (°C)"))
        t = df[!, Symbol("Temperature (°C)")]
        nbad = count(x -> x < -60 || x > 50, t)
        if nbad > 0
            issues = true
            println(@sprintf("[OUTLIER] %d temperature values outside [-60,50]°C", nbad))
        end
    end

    if !issues
        println("No anomalies detected.")
    end
end

# ----------------------------- Terminal Reporting ----------------------------
const HEADER_CRAYON = PrettyTables.Crayon(foreground=:cyan, bold=true)
const STRIPE_CRAYON = PrettyTables.Crayon(background=:blue)
const POSITIVE_CRAYON = PrettyTables.Crayon(foreground=:green, bold=true)
const NEGATIVE_CRAYON = PrettyTables.Crayon(foreground=:red, bold=true)

const TABLE_HIGHLIGHTERS = [
    PrettyTables.TextHighlighter((data, i, j) -> iseven(i), STRIPE_CRAYON),
    PrettyTables.TextHighlighter((data, i, j) -> data[i, j] isa Number && data[i, j] > 0, POSITIVE_CRAYON),
    PrettyTables.TextHighlighter((data, i, j) -> data[i, j] isa Number && data[i, j] < 0, NEGATIVE_CRAYON)
]

function styled_table(data; kwargs...)
    pretty_table(data; highlighters=TABLE_HIGHLIGHTERS, kwargs...)
end

function available_regions(df::DataFrame)
    if !hasproperty(df, :Region)
        return String[]
    end
    raw = [strip(string(r)) for r in skipmissing(df.Region) if strip(string(r)) != ""]
    unique!(raw)
    sort!(raw)
    return raw
end

function print_available_regions(regions::AbstractVector{<:AbstractString})
    println("== Available Regions ==")
    if isempty(regions)
        println(" (no regions found)")
    else
        for r in regions
            println(" - $(r)")
        end
    end
    println()
end

function collect_valid(v)
    out = Float64[]
    for x in v
        if x === missing || x === nothing
            continue
        end
        xv = try
            Float64(x)
        catch
            continue
        end
        if !isnan(xv)
            push!(out, xv)
        end
    end
    return out
end

function metric_stats(values::Vector{Float64})
    if isempty(values)
        return DataFrame(Statistic=String[], Value=Any[])
    end
    stats = [
        ("Count", length(values)),
        ("Mean", round(mean(values); digits=2)),
        ("Median", round(median(values); digits=2)),
        ("Minimum", round(minimum(values); digits=2)),
        ("Maximum", round(maximum(values); digits=2)),
        ("Std. Deviation", length(values) > 1 ? round(std(values); digits=2) : 0.0)
    ]
    return DataFrame(Statistic = first.(stats), Value = Any[x[2] for x in stats])
end

function print_data_preview(df::DataFrame; limit::Int=5)
    rows = min(limit, nrow(df))
    println("\n== Data Preview — first $(rows) rows ==")
    styled_table(first(df, rows))
    if nrow(df) > rows
        println("\n== Data Preview — last $(rows) rows ==")
        styled_table(last(df, rows))
    end
end

function current_month_subset(df::DataFrame)
    if !hasproperty(df, :Date) || isempty(df)
        return (Date(0), DataFrame())
    end
    today = Dates.today()
    subset = filter(:Date => d -> month(d) == month(today) && year(d) == year(today), df)
    label_date = today
    if isempty(subset)
        label_date = maximum(df.Date)
        subset = filter(:Date => d -> month(d) == month(label_date) && year(d) == year(label_date), df)
    end
    return (label_date, subset)
end

function print_current_month_overview(df::DataFrame)
    label_date, subset = current_month_subset(df)
    label = isempty(subset) ? "n/a" : string(Dates.monthname(month(label_date)), " ", year(label_date))
    println("\n== Current Month Overview — $(label) ==")
    if isempty(subset)
        println("[INFO] No data for the current or latest month.")
        return
    end
    metrics = [
        Symbol("Temperature (°C)"),
        Symbol("Snow Depth (cm)"),
        Symbol("Snow_New (cm)"),
        Symbol("Precipitation (mm)"),
        Symbol("Wind (Beaufort)")
    ]
    rows = NamedTuple{(:Metric, :Average, :Minimum, :Maximum),Tuple{String,Float64,Float64,Float64}}[]
    for metric in metrics
        if hasproperty(subset, metric)
            vals = collect_valid(subset[!, metric])
            isempty(vals) && continue
            push!(rows, (Metric=string(metric), Average=round(mean(vals); digits=2), Minimum=round(minimum(vals); digits=2), Maximum=round(maximum(vals); digits=2)))
        end
    end
    if isempty(rows)
        println("[INFO] No numeric metrics available to summarise.")
        return
    end
    styled_table(DataFrame(rows))
end

function print_metric_overall(df::DataFrame, ycol::Symbol; recent_days::Int=14)
    if !hasproperty(df, ycol)
        println("[INFO] $(String(ycol)) not available – skipping.")
        return
    end
    sorted = sort(df, :Date)
    if isempty(sorted)
        println("[INFO] No data for $(String(ycol)).")
        return
    end
    idx_start = max(nrow(sorted) - recent_days + 1, 1)
    slice = sorted[idx_start:end, [:Date, ycol]]
    tbl = DataFrame(Date = slice.Date, Value = slice[!, ycol])
    if ROLLING_DAYS > 1
        rm = rolling_mean(sorted[!, ycol], ROLLING_DAYS)
        tbl.RollingMean = rm[idx_start:end]
    end
    for col in names(tbl)[2:end]
        tbl[!, col] = round.(tbl[!, col]; digits=2)
    end
    rename!(tbl, :Value => ycol)
    if :RollingMean in names(tbl)
        rename!(tbl, :RollingMean => Symbol("$(ROLLING_DAYS)-Day Rolling Mean"))
    end
    println("\n== $(String(ycol)) — last $(size(tbl, 1)) days ==")
    styled_table(tbl)

    values = collect_valid(sorted[!, ycol])
    if isempty(values)
        println("[INFO] No valid values for $(String(ycol)) found.")
    else
        println("\n-- Summary --")
        styled_table(metric_stats(values))
    end
end

function safe_stat(v, f::Function)
    vals = collect_valid(v)
    isempty(vals) && return missing
    return f(vals)
end

function metric_group_summary(df::DataFrame; groupcol::Symbol, ycol::Symbol)
    if !hasproperty(df, groupcol) || !hasproperty(df, ycol)
        return
    end
    grouped = combine(groupby(df, groupcol),
        ycol => (v -> length(collect_valid(v))) => :Count,
        ycol => (v -> safe_stat(v, mean)) => :Average,
        ycol => (v -> safe_stat(v, median)) => :Median,
        ycol => (v -> safe_stat(v, minimum)) => :Min,
        ycol => (v -> safe_stat(v, maximum)) => :Max
    )
    isempty(grouped) && return
    sort!(grouped, :Average, rev=true, by=x -> x isa Missing ? -Inf : Float64(x))
    for col in (:Average, :Median, :Min, :Max)
        grouped[!, col] = map(x -> x isa Missing ? missing : round(x; digits=2), grouped[!, col])
    end
    println("\n== $(String(ycol)) — by $(String(groupcol)) ==")
    styled_table(grouped)
end

function recent_conditions(df::DataFrame; recent_days::Int=14)
    if isempty(df)
        return DataFrame()
    end
    start_idx = max(nrow(df) - recent_days + 1, 1)
    cols = Symbol[:Date]
    for col in (:Region, :Country)
        hasproperty(df, col) && push!(cols, col)
    end
    slice = df[start_idx:end, cols]
    for col in (Symbol("Temperature (°C)"), Symbol("Snow Depth (cm)"), Symbol("Snow_New (cm)"), Symbol("Precipitation (mm)"), Symbol("Wind (Beaufort)"))
        if hasproperty(df, col)
            slice[!, col] = df[start_idx:end, col]
        end
    end
    return slice
end

function print_daily_scoreboard(df::DataFrame; top_n::Int=5)
    snow_col = Symbol("Snow_New (cm)")
    if !hasproperty(df, :Date) || !hasproperty(df, snow_col)
        println("\n[INFO] Unable to build the daily snowfall leaderboard (missing required columns).")
        return
    end
    if isempty(df)
        println("\n[INFO] No rows available for the daily snowfall leaderboard.")
        return
    end
    today = Dates.today()
    day_df = filter(:Date => d -> d == today, df)
    label = "today ($(string(today)))"
    if isempty(day_df)
        latest_date = maximum(df.Date)
        day_df = filter(:Date => d -> d == latest_date, df)
        label = "latest available date ($(string(latest_date)))"
    end
    if isempty(day_df)
        println("\n[INFO] No data rows match the latest available date for the daily snowfall leaderboard.")
        return
    end
    day_df = copy(day_df)
    sort!(day_df, snow_col, rev=true, by=x -> x isa Missing ? -Inf : Float64(x))
    count = min(top_n, nrow(day_df))
    day_df = day_df[1:count, :]

    scoreboard = DataFrame(
        Rank = collect(1:count),
        Region = hasproperty(day_df, :Region) ? map(x -> string(x), day_df.Region) : fill("n/a", count),
        Country = hasproperty(day_df, :Country) ? map(x -> string(x), day_df.Country) : fill("n/a", count),
        Elevation = hasproperty(day_df, Symbol("Elevation (m)")) ? day_df[!, Symbol("Elevation (m)")] : fill(missing, count),
        SnowNew = day_df[!, snow_col],
        Temperature = hasproperty(day_df, Symbol("Temperature (°C)")) ? day_df[!, Symbol("Temperature (°C)")] : fill(missing, count)
    )

    scoreboard.Elevation = map(x -> x === missing || x === nothing ? missing : round(Float64(x); digits=0), scoreboard.Elevation)
    scoreboard.SnowNew = round.(coalesce.(scoreboard.SnowNew, 0.0); digits=1)
    scoreboard.Temperature = map(x -> x === missing || x === nothing ? missing : round(Float64(x); digits=1), scoreboard.Temperature)

    rename!(scoreboard, Dict(
        :Elevation => Symbol("Elevation (m)"),
        :SnowNew => Symbol("Snow_New (cm)"),
        :Temperature => Symbol("Temperature (°C)")
    ))

    println("\n== Daily Snowfall Leaderboard — $(label) ==")
    styled_table(scoreboard)
end

function print_region_history(df::DataFrame, region_name::Union{Nothing,AbstractString}; months::Int=12)
    if isnothing(region_name)
        return
    end
    if !hasproperty(df, :Date) || isempty(df)
        println("\n[INFO] No data available for region $(region_name). Adjust filters or check the region name.")
        return
    end
    region_df = hasproperty(df, :Region) ? filter(:Region => x -> !ismissing(x) && slower(x) == slower(region_name), df) : df
    if isempty(region_df)
        println("\n[INFO] No data available for region $(region_name). Adjust filters or check the region name.")
        return
    end
    latest = maximum(region_df.Date)
    month_start = Date(year(latest), month(latest), 1)
    cutoff = month_start - Month(months - 1)
    recent_df = filter(:Date => d -> d >= cutoff, region_df)
    if isempty(recent_df)
        recent_df = region_df
    end

    month_df = transform(recent_df, :Date => ByRow(d -> Date(year(d), month(d), 1)) => :Month)
    grouped = combine(groupby(month_df, :Month),
        Symbol("Temperature (°C)") => (v -> safe_stat(v, mean)) => :AvgTemperature,
        Symbol("Snow Depth (cm)") => (v -> safe_stat(v, mean)) => :AvgSnowDepth,
        Symbol("Snow_New (cm)") => (v -> sum(collect_valid(v))) => :TotalNewSnow,
        Symbol("Precipitation (mm)") => (v -> safe_stat(v, mean)) => :AvgPrecipitation,
        Symbol("Wind (Beaufort)") => (v -> safe_stat(v, mean)) => :AvgWind
    )

    if isempty(grouped)
        println("\n[INFO] No monthly aggregates available for region $(region_name).")
        return
    end

    sort!(grouped, :Month)
    grouped.Month = Dates.format.(grouped.Month, "yyyy-mm")
    for col in (:AvgTemperature, :AvgSnowDepth, :TotalNewSnow, :AvgPrecipitation, :AvgWind)
        if col in names(grouped)
            grouped[!, col] = map(x -> x isa Missing ? missing : round(x; digits=2), grouped[!, col])
        end
    end

    rename!(grouped, Dict(
        :AvgTemperature => Symbol("Avg Temperature (°C)"),
        :AvgSnowDepth => Symbol("Avg Snow Depth (cm)"),
        :TotalNewSnow => Symbol("Total New Snow (cm)"),
        :AvgPrecipitation => Symbol("Avg Precipitation (mm)"),
        :AvgWind => Symbol("Avg Wind (Beaufort)")
    ))

    println("\n== Region Insights — $(region_name) (last $(months) months) ==")
    styled_table(grouped)
end

function region_top_snow_events(df::DataFrame; top_n::Int=5)
    col = Symbol("Snow_New (cm)")
    if !hasproperty(df, col)
        return DataFrame()
    end
    slice = DataFrame(:Date => df[!, :Date], col => df[!, col])
    if hasproperty(df, Symbol("Snow Depth (cm)"))
        slice[!, Symbol("Snow Depth (cm)")] = df[!, Symbol("Snow Depth (cm)")]
    end
    if hasproperty(df, Symbol("Temperature (°C)"))
        slice[!, Symbol("Temperature (°C)")] = df[!, Symbol("Temperature (°C)")]
    end
    slice = filter(row -> !ismissing(row[col]) && row[col] > 0, slice)
    if isempty(slice)
        return DataFrame()
    end
    sort!(slice, col, rev=true)
    return slice[1:min(top_n, nrow(slice)), :]
end

function print_available_commands()
    println()
    printstyled("Available commands\n"; color=:cyan, bold=true)
    printstyled("  report        "; color=:green, bold=true); println("- default full dashboard (this view)")
    printstyled("  list          "; color=:green, bold=true); println("- list all DACH regions")
    printstyled("  region NAME   "; color=:green, bold=true); println("- deep dive into a single resort (replace NAME)")
    println()
    printstyled("Options:"; color=:yellow, bold=true); println(" --from YYYY-MM-DD | --to YYYY-MM-DD | --season WINTER|SUMMER|ALL")
    printstyled("Environment:"; color=:yellow, bold=true); println(" REGION, CSV_PATH")
    println()
    printstyled("Quick copy:"; color=:magenta, bold=true); println(" $(COMMAND_PREFIX) report")
    printstyled("Region example:"; color=:magenta, bold=true); println(" $(COMMAND_PREFIX) region \"Zermatt\"")
end

function run_report(df::DataFrame, config::CLIConfig)
    regs = available_regions(df)
    print_available_regions(regs)
    print_current_month_overview(df)
    print_daily_scoreboard(df)

    if nrow(df) > 0
        println(@sprintf("\nDataset after filtering: %d rows, %d columns (%s to %s)", nrow(df), ncol(df), string(minimum(df.Date)), string(maximum(df.Date))))
    else
        println("\nDataset after filtering: 0 rows.")
    end

    qc_checks(df)
    print_data_preview(df)

    metrics = [
        Symbol("Temperature (°C)"),
        Symbol("Wind (Beaufort)"),
        Symbol("Precipitation (mm)"),
        Symbol("Snow Depth (cm)"),
        Symbol("Snow_New (cm)")
    ]

    for ycol in metrics
        print_metric_overall(df, ycol)
        for groupcol in (:Region, :Country)
            metric_group_summary(df; groupcol=groupcol, ycol=ycol)
        end
    end

    print_region_history(df, config.region_focus; months=12)
    if isnothing(config.region_focus)
        println("\nTip: set REGION=\"<Region Name>\" before running the script to focus the reports on a single area.")
    end
end

function run_list(df::DataFrame)
    print_available_regions(available_regions(df))
end

function resolve_region_name(df::DataFrame, name::AbstractString)
    regs = available_regions(df)
    target = slower(name)
    for r in regs
        if slower(r) == target
            return (r, String[])
        end
    end
    suggestions = [r for r in regs if occursin(target, slower(r))]
    return (nothing, suggestions)
end

function run_region(df::DataFrame, region_name::Union{Nothing,String})
    if region_name === nothing || strip(String(region_name)) == ""
        println("Please provide a region name, e.g. `$(COMMAND_PREFIX) region \"Zermatt\"`.")
        run_list(df)
        return
    end

    actual, suggestions = resolve_region_name(df, String(region_name))
    if actual === nothing
        println("Region \"$(region_name)\" not found.")
        if !isempty(suggestions)
            println("Did you mean: " * join(suggestions[1:min(5, length(suggestions))], ", ") * "?")
        end
        println("Run `list` to show all available regions.")
        return
    end

    region_df = filter(:Region => x -> !ismissing(x) && slower(String(x)) == slower(actual), df)
    if isempty(region_df)
        println("No data available for region $(actual) after applying filters.")
        return
    end

    country = hasproperty(region_df, :Country) ? unique([string(c) for c in region_df.Country if c !== missing]) : String[]
    country_label = isempty(country) ? "Unknown" : country[1]

    println("== Region Overview — $(actual) ==")
    println(@sprintf("Country: %s | Observations: %d | Date range: %s to %s", country_label, nrow(region_df), string(minimum(region_df.Date)), string(maximum(region_df.Date))))

    print_current_month_overview(region_df)
    print_metric_overall(region_df, Symbol("Snow_New (cm)"); recent_days=14)
    print_metric_overall(region_df, Symbol("Temperature (°C)"); recent_days=14)

    events = region_top_snow_events(region_df; top_n=5)
    if !isempty(events)
        println("\n== Top fresh snow days ==")
        styled_table(events)
    end

    recent = recent_conditions(region_df; recent_days=14)
    if !isempty(recent)
        println("\n== Recent conditions (last 14 days) ==")
        styled_table(recent)
    end

    print_region_history(region_df, actual; months=12)
end

# ----------------------------- Main ------------------------------------------
function main()
    config = parse_cli()
    df = load_data(config.csv_path)
    add_newsnow!(df)
    df = apply_filters(df, config.runargs)

    if isempty(df)
        println("No data available after applying filters.")
        print_available_commands()
        return
    end

    if config.command == :list
        run_list(df)
    elseif config.command == :region
        run_region(df, config.region_focus)
    else
        run_report(df, config)
    end

    println("\nDone. Terminal reporting finished.")
    print_available_commands()
end

main()
